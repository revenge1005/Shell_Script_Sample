#!/bin/bash

### 사용처 ###
# 처리 시간이 긴 셸 스크립트를 실행하는데 프로세스를 정지하지 ㅇ낳고 내부 실행 상태를 표시하고 싶을 떄

### 사용 명령어 ###
# trap, nc, sleep

### 해설 ###
# 이 스크립트는 반복 처리를 하여 통신 시간이 긴 스크립트가 실행 중일 때 해당 프로세스에 kill 명령어로 USR1 시그널을 모내서 지금까지 반복한 실행 횟수를 표시한다.

# 여기서 nc 명령어를 사용해 TCP 포트 80으로 보내는데 지금까지 반복한 횟수를 "Try Count:"로 표시한다.

################################################################################################################################################################

# 실행 횟수
count=0   #(1)
# 통신 대상 서버
server="192.168.2.105"   #(2)

# 시그널 USR1 트랩 설정. 현재 $count 표시
#(3)
trap 'echo "Try Count: $count"' USR1

# nc 명령어로 연속 통신 확인 반복
#(4)
while [ "$count" -le 1000 ]
do
  # 카운터 1 늘리고 nc 명령어 실행
  # 마지막에 1초 대기
  #(5)
  count=$(expr $count  + 1)
  nc -zv "$server" 80
  sleep 1
done

################################################################################################################################################################

# 실행 중인 프로세스 상태를 알려면 프로세스에 시그널을 보내고 그때의 내부 상태를 표시하는 방법이 있다.

# 셸 스크립트에서 이런 시그널 처리를 하려면 trap 명령어를 사용한다.

# 예제에서 사용하는 USR1 시그널은 애플리케이션마다 원하는 대로 기능을 지정하는 시그널이다.
# 예를 들어 웹 서버로 자주 쓰는 아파치(httpd)에 USR1 시그널이 오면 graceful 모드로 '자연스럽게 재기동'을 하고 
# 리눅스 dd 명령어에 USR1 시그널을 보내면 명령를 계속 실행하면서 '지금까지 처리한 블록 수'를 표시한다.

# (1)과 (2)에서 확인 횟수 카운터를 초기하고 대상 서버를 정의한다.

# (3)은 시그널을 수신했을 때 어떤 처리를 할지 작성한 부분이다.
# (3) 부분은 스크립트를 위에서부터 순서대로 실행할 때는 아무것도 표시되지 않는다.
# 실행 중에 실제로 USR 시그널이 왔을 때 이 처리를 하도록 정의한 문자이라고 이해하기 바란다
# 이렇게 셸 스크립트에서는 trap 명령어를 사용해서 끼어들기 처리를 작성할 수 있다.

# (4)에서 while문으로 통신 확인(실행 시간이 긴 처리)를 한다.
# 카운터를 1 늘어가며 1000번 실행, (5)에서 nc 명령어로 대상 서버 80 포트로 통신 확인을 하고 sleep 명령어로 1초씩 기다른 다음 expr 명령어로 셸 변수 count 값을 늘린다.

