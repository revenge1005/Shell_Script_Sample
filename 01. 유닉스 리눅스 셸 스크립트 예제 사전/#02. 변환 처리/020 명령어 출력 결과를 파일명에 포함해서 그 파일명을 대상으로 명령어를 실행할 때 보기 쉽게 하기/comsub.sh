#!/bin/bash

### 사용처 ###
# 명령어 치환 처리르 끼워 넣고(네스트) 싶을 때

### 사용 명령어 ###
# hostname, grep

### 해설 ###
# 이 스크립트는 hostname 명령어로 파일명을 조합한 로그 파일에 ERROR라는 문자열을 검색하여 일치한 줄을 표시한다.
# 검색 카운터에는 【grep 명령어의 -c 옵션】을 사용하며, 예제에서 "명령어 치환"을 할 때 검색 대상 로그 파일이 다음과 같다고 가장한다.
# 여기서 파일명이 "쉘 변수명 + 언더스코어 + log"라는 변수명 뒤에 언더스코어가 올 때 주의점을 살표보자
# ㆍ /var/log/myapp 디렉토리 안에 "(서버명).log" 라는 로그 파일이 저장됨
# ㆍ 이 스크립트를 실행하는 서버 호스트명은 "ubuntu"임 - hostname 명령 결과
# ㆍ ubuntu.log 라는 텍스트 파일 내용은 (2)과 같음

err_count=$(grep -c "ERRO" /var/log/myapp/$(hostname).log)   ## -------- (1) -------- ##
echo "Error counts: $err_count"


#### 명령어 치환(Command Substitution) ####
# 스크립트에서 어떤 명령어 출력 결과를 그대로 스크립트에서 변수에 대입하고 싶을 때 " ` "를 사용하며, 
# 이것을 명령어 치환(Command Substitution)이라고 한다. 

## 다음은 date 명령어 출력을 사용해서 오늘 날짜를 출력하는 예제이다. ##
# date_str=`date +"%Y%m%d"`
# echo $date_str

# 하지만 " ` "를 쓴 명령어 치환은 네스트(끼워 넣기)하여 처리하기가 번거롭다. 
# 예제 (1)을 " ` "를 쓴 방법으로 작성하면 다음처럼 내부에 `(그레이브)를 \로 이스케이프해야 한다.
# err_count=`grep -c "ERROR" /var/log/myapp/\`hostname\`.log`

# 매번 이스케이프하는 것도 큰 일이고 기존 스크립트를 수정할 때 이 부분에 변경이 있다면 이스케이프를 빠트릴지도 모른다. 
# 따라서이 예제에서 쓰는 " $( ) " 표기법을 추천하다.

# 이 방법의 장점은 처리를 네스트하더라도 기존 명령어 치환 부분을 이스케이프하지 않아도 된다라는 점이다.
# 따라서 기존 코드를 수정할 때에는 처리 내부 코드를 수정할 필요가 없으므로 보수 성이 뛰어나다.

# 또한 괄호 대응이라는 알기 쉬운 표기법으로 명령어 치환 부분을 작성하므로 코드가 읽기 쉽다는 장점도 있다.